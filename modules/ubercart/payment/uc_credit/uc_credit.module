<?php

/**
 * @file
 * Defines the credit card payment method and hooks in payment gateways.
 */

use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Url;
use Symfony\Component\HttpFoundation\RedirectResponse;

/** Just authorize an amount on a credit card account. */
define('UC_CREDIT_AUTH_ONLY', 'authorize');

/** Capture funds from a prior authorization. */
define('UC_CREDIT_PRIOR_AUTH_CAPTURE', 'prior_auth_capture');

/** Authorize and capture money all at once. */
define('UC_CREDIT_AUTH_CAPTURE', 'auth_capture');

/** Set up a credit card reference through the payment gateway. */
define('UC_CREDIT_REFERENCE_SET', 'reference_set');

/** Capture funds using a credit card reference. */
define('UC_CREDIT_REFERENCE_TXN', 'reference_txn');

/** Remove a reference from the payment gateway. */
define('UC_CREDIT_REFERENCE_REMOVE', 'reference_remove');

/** Credit funds to a reference at the payment gateway. */
define('UC_CREDIT_REFERENCE_CREDIT', 'reference_credit');

/** Credit funds to a credit card account. */
define('UC_CREDIT_CREDIT', 'credit');

/** Void a transaction before the transaction clears. */
define('UC_CREDIT_VOID', 'void');


/** Name of encryption key file. */
define('UC_CREDIT_KEYFILE_NAME', 'uc_credit.key');


/**
 * Implements hook_help().
 */
function uc_credit_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    case 'uc_credit.terminal':
      return '<p>' . t('Use this terminal to process credit card payments through your default gateway.') . '</p>';
  }
}

/**
 * Implements hook_theme().
 */
function uc_credit_theme() {
  return array(
    'uc_credit_cvv_help' => array(
      'variables' => array(),
      'file' => 'uc_credit.theme.inc',
      'function' => 'theme_uc_credit_cvv_help',
    ),
  );
}

/**
 * Implements hook_form_FORM_ID_alter() for uc_cart_checkout_form().
 */
function uc_credit_form_uc_cart_checkout_form_alter(&$form, FormStateInterface $form_state) {
  // Cache the CC details for use in other functions.
  $session = \Drupal::service('session');
  if ($session->has('sescrd')) {
    uc_credit_cache('save', $session->get('sescrd'));

    // Store the encrypted details to the form for processing on submit.
    $form['payment_details_data'] = array(
      '#type' => 'hidden',
      '#value' => $session->get('sescrd'),
    );

    // Clear the session of the details.
    $session->remove('sescrd');
  }
  $session->remove('cc_pay');
}

/**
 * Implements hook_form_FORM_ID_alter() for uc_cart_checkout_review_form().
 */
function uc_credit_form_uc_cart_checkout_review_form_alter(&$form, FormStateInterface $form_state) {
  // Check if the customer paid by CC and refreshed on the review page.
  $session = \Drupal::service('session');
  if ($session->has('cc_pay') && !$session->has('sescrd') && empty($_POST['sescrd'])) {
    // Send them back to the checkout form to put in their details again.
    drupal_set_message(t('To protect our customers from identity theft, credit card details are erased when a browser refreshes on the checkout review page.  Please enter your card details again and re-submit the form.'), 'error');

    $session->set('clear_cc', TRUE);
    $session->remove('cc_pay');
    return new RedirectResponse(Url::fromRoute('uc_cart.checkout')->toString());
  }

  if ($session->has('sescrd')) {
    // Cache the CC details for use in other functions.
    uc_credit_cache('save', $session->get('sescrd'));

    // Store the encrypted details to the form for processing on submit.
    $form['sescrd'] = array(
      '#type' => 'hidden',
      '#value' => base64_encode($session->get('sescrd')),
    );
  }
  else {
    $form['sescrd'] = array(
      '#type' => 'hidden',
      '#value' => '',
    );
  }

  // Add submit handler to preserve CC details for the back button and
  // failed order submissions.
  $form['actions']['back']['#submit'][] = 'uc_credit_cart_review_back_submit';

  // Reconstruct the submit handler array for before and after processing.
  $submit = array_merge(array('uc_credit_cart_review_pre_form_submit'), $form['#submit']);
  $submit[] = 'uc_credit_cart_review_post_form_submit';

  $form['#submit'] = $submit;

  // Clear the session of the details.
  $session->remove('sescrd');
}

/**
 * Implements hook_exit().
 */
function uc_credit_exit() {
  // Make sure sensitive checkout session data doesn't persist on other pages.
  $session = \Drupal::service('session');
  if ($session->has('sescrd')) {
    // Separate the args ourself since the arg() function may not be loaded.
    $args = explode('/', Url::fromRoute('<current>')->toString());
    if (!isset($args[1]) || $args[1] != 'checkout') {
      $session->remove('sescrd');
    }
  }
}

/**
 * Implements hook_uc_store_status().
 */
function uc_credit_uc_store_status() {
  // Throw up an error row if encryption has not been set up yet.
  if ($key = uc_credit_encryption_key()) {
    $statuses[] = array(
      'status' => 'ok',
      'title' => t('Credit card encryption'),
      'desc' => t('Credit card data is encrypted during checkout for maximum security.'),
    );
  }
  else {
    $statuses[] = array(
      'status' => 'error',
      'title' => t('Credit card encryption'),
      'desc' => t('You must review your <a href=":url">credit card security settings</a> and enable encryption before you can accept credit card payments.', [':url' => Url::fromRoute('uc_credit.settings')->toString()]),
    );
  }

  return $statuses;
}

/**
 * Implements hook_uc_payment_method().
 */
function temp_uc_credit_uc_payment_method() {
  if (\Drupal::routeMatch()->getRouteName() == 'uc_cart.cart' && uc_credit_encryption_key() === FALSE) {
    return;
  }
  $credit_config = \Drupal::config('uc_credit.settings');

  $path = base_path() . drupal_get_path('module', 'uc_credit');
  $title = t('Credit card:');
  $cc_types = array(
    'visa' => t('Visa'),
    'mastercard' => t('MasterCard'),
    'discover' => t('Discover'),
    'amex' => t('American Express'),
  );
  foreach ($cc_types as $type => $label) {
    if ($credit_config->get($type)) {
      $image = array(
        '#theme' => 'image',
        '#uri' => drupal_get_path('module', 'uc_credit') . '/images/' . $type . '.gif',
        '#alt' => $label,
        '#attributes' => array('class' => array('uc-credit-cctype', 'uc-credit-cctype-' . $type)),
      );
      $title .= ' ' . \Drupal::service('renderer')->renderPlain($image);
    }
  }
  $methods['credit'] = array(
    'name' => t('Credit card'),
    'title' => $title,
    'callback' => 'uc_payment_method_credit',
    'weight' => 2,
    'checkout' => TRUE,
  );

  return $methods;
}

/**
 * Returns a credit card number with appropriate masking.
 */
function uc_credit_display_number($number) {
  if (strlen($number) == 4) {
    return t('(Last 4) ') . $number;
  }

  return str_repeat('-', 12) . substr($number, -4);
}

/**
 * Caches CC details on a pageload for use in various functions.
 *
 * @param $op
 *   The cache operation to perform; either 'save', 'load', or 'clear'.
 * @param $data
 *   The encrypted, serialized string containing the CC data.
 *
 * @return
 *   An array of credit card details.
 */
function uc_credit_cache($op, $data = NULL, $encrypted = TRUE) {
  // The CC data will be stored in this static variable.
  static $cc_cache = array();

  if ($op == 'save') {
    if ($encrypted) {
      // Initialize the encryption key and class.
      $key = uc_credit_encryption_key();
      $crypt = \Drupal::service('uc_store.encryption');

      // Save the unencrypted CC details for the duration of this request.
      // In recent versions, we base64_encode() the payment details before
      // encrypting. We can detect encoded data by the lack of colons,
      // due to base64's limited character set.
      $data = $crypt->decrypt($key, $data);
      if (strpos($data, ':') === FALSE) {
        $data = base64_decode($data);
      }
      $cc_cache = @unserialize($data);
    }
    else {
      $cc_cache = $data;
    }
  }
  elseif ($op == 'clear') {
    $cc_cache = array();
  }

  return $cc_cache;
}

/**
 * Caches the encrypted CC data on the review order form for processing.
 */
function uc_credit_cart_review_back_submit($form, FormStateInterface $form_state) {
  $session = \Drupal::service('session');
  $session_card_data = base64_decode($_POST['sescrd']);

  $session->set('sescrd', $session_card_data);
  uc_credit_cache('save', $session_card_data);
}

/**
 * Caches the encrypted CC data on the review order form for processing.
 */
function uc_credit_cart_review_pre_form_submit($form, FormStateInterface $form_state) {
  $session = \Drupal::service('session');
  $session_card_data = base64_decode($_POST['sescrd']);

  $session->set('sescrd', $session_card_data);
  uc_credit_cache('save', $session_card_data);
}

/**
 * Clears the temporary CC data if the review order form submits.
 */
function uc_credit_cart_review_post_form_submit($form, FormStateInterface $form_state) {
  $session = \Drupal::service('session');
  $complete = array();
  if ($session->has('uc_checkout')) {
    $complete = $session->get('uc_checkout');
  }
  if (!empty($complete[$session->get('cart_order')]['do_complete'])) {
    // Otherwise stuff it back in the session for the next pageload.
    $session->remove('sescrd');
  }
}

/**
 * Validates a CVV number during checkout.
 */
function _uc_credit_valid_cvv($cvv) {
  $digits = array();

  $credit_config = \Drupal::config('uc_credit.settings');
  if ($credit_config->get('visa') ||
      $credit_config->get('mastercard') ||
      $credit_config->get('discover')) {
    $digits[] = 3;
  }
  if ($credit_config->get('amex')) {
    $digits[] = 4;
  }

  // Fail validation if it's non-numeric or an incorrect length.
  if (!is_numeric($cvv) || (count($digits) > 0 && !in_array(strlen($cvv), $digits))) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Validates a credit card number during checkout.
 *
 * Luhn algorithm.  See: http://www.merriampark.com/anatomycc.htm
 */
function _uc_credit_valid_card_number($number) {
  $id = substr($number, 0, 1);
  $credit_config = \Drupal::config('uc_credit.settings');
  if (($id == 3 && !$credit_config->get('amex')) ||
      ($id == 4 && !$credit_config->get('visa')) ||
      ($id == 5 && !$credit_config->get('mastercard')) ||
      ($id == 6 && !$credit_config->get('discover')) ||
      !ctype_digit($number)) {
    return FALSE;
  }

  $total = 0;
  for ($i = 0; $i < strlen($number); $i++) {
    $digit = substr($number, $i, 1);
    if ((strlen($number) - $i - 1) % 2) {
      $digit *= 2;
      if ($digit > 9) {
        $digit -= 9;
      }
    }
    $total += $digit;
  }

  if ($total % 10 != 0) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Validates a start date on a card.
 *
 * @param $month
 *   The 1 or 2-digit numeric representation of the month, i.e. 1, 6, 12.
 * @param $year
 *   The 4-digit numeric representation of the year, i.e. 2008.
 *
 * @return
 *   TRUE for cards whose start date is blank (both month and year) or in the
 *   past, FALSE otherwise.
 */
function _uc_credit_valid_card_start($month, $year) {
  if (empty($month) && empty($year)) {
    return TRUE;
  }

  if (empty($month) || empty($year)) {
    return FALSE;
  }

  if ($year > date('Y')) {
    return FALSE;
  }
  elseif ($year == date('Y')) {
    if ($month > date('n')) {
      return FALSE;
    }
  }

  return TRUE;
}

/**
 * Validates an expiration date on a card.
 *
 * @param $month
 *   The 1 or 2-digit numeric representation of the month, i.e. 1, 6, 12.
 * @param $year
 *   The 4-digit numeric representation of the year, i.e. 2008.
 *
 * @return
 *   TRUE for non-expired cards, FALSE for expired.
 */
function _uc_credit_valid_card_expiration($month, $year) {
  if ($year < date('Y')) {
    return FALSE;
  }
  elseif ($year == date('Y')) {
    if ($month < date('n')) {
      return FALSE;
    }
  }

  return TRUE;
}

/**
 * Validates an issue number on a card; returns TRUE or FALSE.
 */
function _uc_credit_valid_card_issue($issue) {
  if (empty($issue) || (is_numeric($issue) && $issue > 0)) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Loads the key for CC number encryption from a file.
 *
 * Path to key file is stored in system variable 'uc_credit_encryption_path'.
 * Key file name is stored in constant UC_CREDIT_KEYFILE_NAME.
 *
 * @return
 *   FALSE if no encryption key is found.
 */
function uc_credit_encryption_key() {
  static $key = FALSE;

  if (empty($key)) {
    $config = \Drupal::config('uc_credit.settings');
    $key_file = $config->get('encryption_path') . '/' . UC_CREDIT_KEYFILE_NAME;
    $contents = @file_get_contents($key_file);
    if (strlen($contents) == 32) {
      $key = $contents;
    }
  }

  return $key;
}

/**
 * Saves a CC data array to an order's data array.
 */
function _uc_credit_save_cc_data_to_order($cc_data, $order_id) {
  // Save only some limited, PCI compliant data.
  $cc_data['cc_number'] = substr($cc_data['cc_number'], -4);
  unset($cc_data['cc_cvv']);

  // Load up the existing data array.
  $data = db_query("SELECT data FROM {uc_orders} WHERE order_id = :id", [':id' => $order_id])->fetchField();
  $data = unserialize($data);

  // Stuff the serialized and encrypted CC details into the array.
  $crypt = \Drupal::service('uc_store.encryption');
  $data['cc_data'] = $crypt->encrypt(uc_credit_encryption_key(), base64_encode(serialize($cc_data)));
  uc_store_encryption_errors($crypt, 'uc_credit');

  // Save it again.
  db_update('uc_orders')
    ->fields(array('data' => serialize($data)))
    ->condition('order_id', $order_id)
    ->execute();
}

/**
 * Returns an array of default credit card transaction types.
 */
function uc_credit_transaction_types() {
  $types = array(
    UC_CREDIT_AUTH_ONLY => t('Authorization only'),
    UC_CREDIT_PRIOR_AUTH_CAPTURE => t('Prior authorization capture'),
    UC_CREDIT_AUTH_CAPTURE => t('Authorize and capture immediately'),
    UC_CREDIT_REFERENCE_TXN => t('Reference transaction'),
  );

  return $types;
}

/**
 * Stores a credit card authorization to an order's data array.
 *
 * @param $order_id
 *   The order associated with the credit card authorization.
 * @param $auth_id
 *   The payment service's ID for the authorization.
 * @param $amount
 *   The amount that was authorized on the card.
 *
 * @return
 *   The entire updated data array for the order.
 */
function uc_credit_log_authorization($order_id, $auth_id, $amount) {
  // Load the existing order data array.
  $data = db_query("SELECT data FROM {uc_orders} WHERE order_id = :id", [':id' => $order_id])->fetchField();
  $data = unserialize($data);

  // Add the authorization to the cc_txns.
  $data['cc_txns']['authorizations'][$auth_id] = array(
    'amount' => $amount,
    'authorized' => REQUEST_TIME,
  );

  // Save the updated data array to the database.
  db_update('uc_orders')
    ->fields(array('data' => serialize($data)))
    ->condition('order_id', $order_id)
    ->execute();

  return $data;
}

/**
 * Logs the capture of a prior authorization to an order's data array.
 *
 * @param $order_id
 *   The order associated with the credit card capture.
 * @param $auth_id
 *   The payment service's ID for the authorization that was captured.
 *
 * @return
 *   The entire updated data array for the order or FALSE to indicate the
 *   specified authorization was not found.
 */
function uc_credit_log_prior_auth_capture($order_id, $auth_id) {
  // Load the existing order data array.
  $data = db_query("SELECT data FROM {uc_orders} WHERE order_id = :id", [':id' => $order_id])->fetchField();
  $data = unserialize($data);

  // Return FALSE if we can't find the authorization.
  if (empty($data['cc_txns']['authorizations'][$auth_id])) {
    return FALSE;
  }

  // Otherwise log the capture timestamp to the authorization.
  $data['cc_txns']['authorizations'][$auth_id]['captured'] = REQUEST_TIME;

  // Save the updated data array to the database.
  db_update('uc_orders')
    ->fields(array('data' => serialize($data)))
    ->condition('order_id', $order_id)
    ->execute();

  return $data;
}

/**
 * Logs a credit card reference to an order's data array.
 *
 * @param $order_id
 *   The order associated with the credit card details.
 * @param $ref_id
 *   The payment service's ID for the reference that may be used to charge the
 *     same credit card at a later date.
 * @param $cc_number
 *   The credit card number associated with this reference.  Only the last 4
 *     digits will be stored.
 *
 * @return
 *   The entire updated data array for the order.
 */
function uc_credit_log_reference($order_id, $ref_id, $cc_number) {
  // Load the existing order data array.
  $data = db_query("SELECT data FROM {uc_orders} WHERE order_id = :id", [':id' => $order_id])->fetchField();
  $data = unserialize($data);

  $data['cc_txns']['references'][$ref_id] = array(
    'card' => substr($cc_number, -4),
    'created' => REQUEST_TIME,
  );

  // Save the updated data array to the database.
  db_update('uc_orders')
    ->fields(array('data' => serialize($data)))
    ->condition('order_id', $order_id)
    ->execute();

  return $data;
}
